## day 11

* XSS is a web application vulnerability that lets attackers inject malicious code (usually javascript) into input fields that reflects content viewed by other users. It can lead to stealing credentials, deface pages or impersonate users.

* types of xss (exist many other types..)

- reflected:
you see reflected variants when injection is immediately projected in a response.
example:
> https://trygiftme.thm/search?term=<script>alert( atob("VEhNe0V2aWxfQnVubnl9") )</script>
You could act, view information, or modify information that the victim or any user could do, view, or access.

- stored:
occurs when malicious script is saved on the server and then loaded for every user who views the affected page.
example: (inject js in a post comment)
```sh
comment=<script>alert(atob("VEhNe0V2aWxfU3RvcmVkX0VnZ30="))</script> + "This gift set my carpet on fire but my kid loved it!"
```
This lets the attacker run code as if they were the victim in order to perform malicious actions such as: Steal session cookies, Trigger fake login popups, or Deface the page.


- Reflected XSS targets individual victims,  while Stored XSS becomes a "set-and-forget" attack, anyone who loads the page runs the attacker’s script.

* protecting against XSS:
- Disable dangerous rendering raths: Instead of using the **innerHTML** property, which lets you inject any content directly into HTML, use the **textContent** property instead, it treats input as text and parses it for HTML.
- Make cookies inaccessible to JS: Set session cookies with the **HttpOnly**, **Secure**, and **SameSite** attributes to reduce the impact of XSS attacks.
- Sanitise input/output and encode: applications may need to accept limited HTML input—for example, to allow users to include safe links or basic formatting. Sanitising and encoding removes or escapes any elements that could be interpreted as executable code, such as scripts, event handlers, or JavaScript URLs while preserving safe formatting.

* exploiting reflected/stored XSS:
1. use test payloads to check if injected code runs. example:
```js
<script>alert('Reflected/Stored Meow Meow')</script>
```

2. use advanced payloads (with cheat sheet help)
> https://portswigger.net/web-security/cross-site-scripting/cheat-sheet



## day 12

* spam vs phishing
- Spam is just digital noise: annoying, but mostly harmless. Phishing, however, is a precision strike.
- Spam focuses on quantity over precision.

* common phishing techniques:
- impersonation (person/department/service)
- Social Engineering
- Typosquatting and Punycode
1. Typosquatting is when an attacker registers a common misspelling of an organisation's domain (typos, missing character, letters reversed...).

2. punycode is a special encoding system that converts Unicode characters (used in writing systems like Chinese, Cyrillic, and Arabic) into ASCII (accepted format by DNS). example:
**tryhackme.com** domain written with **тrу** instead (Cyrillic т, Cyrillic г, Cyrillic у) results in: **xn--hackme-oof3jk.com** where:
xn--: ACE prefix, -oof3jk: encoded non-ascii chars
An easy way to identify punycodes is by looking at the field Return-Path in the email headers.

3. Spoofing:
The message looks like it came from a trusted sender (the display name and “From:” you see in the preview), but the underlying headers tell a different story. Modern email clients can easily reject spoofing attempts.
Checking some essential fields in the email headers: Authentication-Results, Return-Path..
On Authentication-Results, SPF, DKIM, and DMARC are security checks that help confirm if an email really comes from who it says it does:
**SPF**: Says which servers are allowed to send emails for a domain (like a list of approved senders).
**DKIM**: Adds a digital signature to prove the message wasn’t changed and really came from that domain.
**DMARC**: Uses SPF and DKIM to decide what to do if something looks fake (for example, send it to spam or block it).
If both SPF and DMARC fail, it’s a strong sign the email is spoofed.
On the Return-Path we can see the real mail address.

4. Malicious Attachments
Malicious attachments can have multiple goals, either installing malware, stealing passwords, or giving attackers access to the device or network.
example: HTA/HTML files are commonly used for phishing because they run without browser sandboxing, meaning scripts have full access to the endpoint they execute on!


* trending phishing:
In short, most phishing attacks aren’t about dropping malware directly; they’re focusing on stealing access using:

- legitimate apps (Dropbox, Google Drive/Docs, and OneDrive...)

- fake logon pages

- malicious files

- fake invoices

- Side Channel Communications
attacker moves the conversation off email to another channel, such as SMS, WhatsApp/Telegram, a phone or video call, a texted link, or a shared document platform, to continue the social engineering in a platform without the company's control.



## day 13

* YARA = Yet Another Recursive Acronym
* YARA is an open-source tool built to identify and classify malware by searching for unique patterns, the digital fingerprints left behind by attackers.
* it scans code, files, and memory for subtle traces that reveal a threat’s identity.
* it allows you to define your own rules, providing your own view of what constitutes "malicious" behavior.
* it brings several key advantages: speed, flexibility, control, shareability, visibility...
* YARA empowers defenders to move from passive monitoring to active hunting.
* A YARA rule is built from several key elements:
    - Metadata: information about the rule itself: who created it, when, and for what purpose.
    - Strings: the clues YARA searches for: text, byte sequences, or regular expressions that mark suspicious content.
    - Conditions: the logic that decides when the rule triggers, combining multiple strings or parameters into a single decision.
* Example:
```sh
rule rule_name
{
    meta:
        author = "author"
        description = "description"
        date = "2025-10-10"
    strings:
        $s1 = "rundll32.exe" fullword ascii
        $s2 = "msvcrt.dll" fullword wide
        $url1 = /http:\/\/.*malhare.*/ nocase
    condition:
        any of them
}
```
* metadata is optional but recommanded (especially when collection of YARA rules grow)
* Strings (3 main types):
    - Text strings
        1. YARA treats it by default as ascii and case-sensitive
        2. special modifiers: encoding, case tricks, or even encryption (nocase, wide, ascii, xor, base64...)
        3. wide and ascii modifiers can be used both together
    - Hexadecimal strings
        1. to detect malware fragments like file headers, shellcode, or binary signatures
        2. example:
        ```sh
        $mz = { 4D 5A 90 00 }   // MZ header of a Windows executable
        $hex_string = { E3 41 ?? C8 G? VB }
        ```
    - Regular expression strings
        1. useful for spotting URLs, encoded commands, or filenames that share a structure but differ slightly each time.
        2. example:
        ```sh
        $url = /http:\/\/.*malhare.*/ nocase
        $cmd = /powershell.*-enc\s+[A-Za-z0-9+/=]+/ nocase
        ```
* Conditions: (matching)
    - single string:         $str
    - any string:            any of them
    - all strings:           all of them
    - Combine logic using:   and, or, not
    - Use comparisons like:  filesize, entrypoint, or hash (example: any of them and (filesize < 700KB))

* YARA usage: (man yara)
    - -r: Allows YARA to scan directories recursively and follow symlinks
    - -s: Prints the strings found within files that match the rule
    - example:
    ```sh
    yara -r icedid_starter.yar C:\
    ```